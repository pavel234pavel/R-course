---
title: "Семинар 1. Первый раз в первый класс!"
date: "Sep 10, 2018"
output:
  html_document:
    keep_md: no
    number_sections: yes
    toc: yes
lang: ru-RU
editor_options:
  chunk_output_type: console
---

# На плечах гигантов :)

Базовый R умеет не так много. Сила R во множестве пакетов, написанных добровольцами.
Пакеты содержат вкусные и сочные функции и расширяют возможности R.

Чтобы начать использовать любой пакет, скажем, `tidyverse`, нужно сделать два действия.

  - установить пакет: это действие выполняется один раз и скорее всего оно уже сделано :)
  - подключить пакет: это действие выполняется каждый раз при начале работы!

Установка пакеты: в меню Rstudio `Tools` - `Install packages`.

Подключаем пакет `tidyverse`, `rio` и `skimr`!

```{r}
library(tidyverse) # манипуляции с данными
library(rio) # импорт разных форматов
library(skimr) # описательные статистики
```

Пакет `tidyverse` - это коллекция из множества пакетов. Например, в `tidyverse` входят:
  - `dplyr` для манипуляций с данными
  - `ggplot2` для построения графиков
  - `lubridate` для работы с датами во временных рядах

А два других:
  - `rio` импортирует и экспортирует данные практически во все известные форматы;
  - `skimr` считает самые разнообразные описательные статистики, которые только можно представить.



Если при подключении пакета возникает ошибка (Error), то скорее всего пакет не установлен и его нужно установить через меню `Tools` - `Install packages`.

* Упражнение 1.

Подключите пакеты `lattice` и `DataExplorer`.
Не забудьте раскомментировать строки, убрав решетку `#`.

```{r}
# library(___)
# library(___)
```

Что умеют эти пакеты?
  - `lattice` пригодится нам для графиков
  - `DataExplorer` для быстрого автоматического графического анализа

Загружаем данные из spss.

Предварительно должен быть подключен пакет `rio`.

После загрузки мы сразу проверяем целостность данных командой `glimpse()`.
Также разумно посмотреть на первые строки набора данных командой `head()`
и на последние командой `tail()`.

```{r}
some <- import("data/manipulate.sav")
glimpse(some)
head(some)
tail(some)
```

- Сколько переменных в наборе данных?
- Сколько наблюдений?

* Упражнение 2.

Загрузите данные `cola.dta` из stata.
Посмотрите на первые и последние строки.
- Сколько переменных в наборе данных?
- Сколько наблюдений?

```{r}
# cola <- ___
# glimpse(cola)
# head(___)
# tail(___)
```

Исключение составляет только загрузка данных `eviews`.
Пакет `rio`, выложенный на официальный репозиторий пакетов CRAN, ещё не умеет импортировать его.
Однако разрабатываемая версия `rio` уже справляется.
Ставим версию `rio` от разработчика

```{r}
# devtools::install_github("leeper/rio")
```

И спокойно импортируем данные формата `eviews`:
```{r}
housing <- import("data/housing.wf1")
glimpse(housing)
```


# Первый взгляд

Возьмём встроенный в пакет `ggplot2` набор данных про бриллианты.

```{r}
df <- diamonds
```

Для описательных статистик понадобится подключённый ранее пакет `skimr`.

```{r}
skim(df)
```

- Сколько в среднем весит бриллиант?
- Сколько различных видов огранки бриллиантов есть в данных?

Дальше будем строить гистограммы! Если нужно посмотреть по-быстрому, то можно
сделать так:

```{r}
qplot(data = df, x = carat)
```
Но вообще на графиках должны быть подписаны оси и название.

```{r}
qplot(data = df, x = carat) +
  labs(x = "Вес", y = "Количество", title = "Распределение бриллиантов по весу")
```

Потренируемся с качественными переменными и нарисуем гистограмму для качества
огранки бриллианта.

```{r}
qplot(data = df, x = cut)  +
  labs(x = "Качество огранка", y = "Количество", title = "Распределение бриллиантов по огранке")
```

C помощью `qplot` можно создавать и диаграммы рассеяния. Посмотрим сразу на
цену бриллианта и его вес.

```{r}
qplot(data = df, x = carat, y = price)
```

А можно визуализировать сразу несколько диаграмм!
Для этого, например, используется пакет `lattice` и функция `splom`.

```{r}
library(lattice) # загружаем пакет
splom(df[1:1000, c("carat", "depth", "table")]) # строим диаграммы рассеяния для 1000 наблюдений
```

* Упражнение 3.

Постройте гистограмму для цены бриллианта. Она находится в столбце `price`
набора данных под названием `df`. Не забудьте подписать оси и придумать название.

```{r}
# qplot(data = ___, x = ___) +
#  labs(x = ___, y = ___, title = ___)
```

Постройте диаграмму рассеяния: по оси абсцисс изобразите параметры
бриллианта (столбец `depth`), по оси ординат — цену (`price`).

```{r}
# qplot(data = ___, x = ___, y = ___) +
#  labs(___)
```

# Одним махом!

Есть и пакеты для автоматического графического анализа данных, например, `DataExplorer`.

Если до прихода гостей осталось 5 минут и нужно быстро глянуть на данные:

```{r}
library(DataExplorer)
create_report(diamonds)
```

# Возня с данными

Отобрать наблюдения по нескольким критериям можно с помощью команды `filter()`

- По каким критериям отобраны бриллианты?

```{r}
diamonds2 <- filter(diamonds, price > mean(price), carat < mean(carat))
skim(diamonds2)
```

* Упражнение 4.

Отберите бриллианты с длиной, переменная `x`, больше 5 мм.
- Чему равна их средняя цена?

```{r}
# diamonds3 <- filter(___, ___)
# skim(___)
```

Перейдём к созданию новых переменных!

Мы добавим в набор данных логарифм цены каждого бриллианта.
- Под каким названием добавлена переменная в набор данных?

```{r}
diamonds4 <- mutate(diamonds, lprice = log(price))
skim(diamonds4)
```

* Упражнение 5.

Добавьте в набор данных для каждого бриллианта стоимость одного карата.
- Чему равна медианная стоимость одного карата?

```{r}
# diamonds5 <- mutate(diamonds, carat_price = ___)
# skim(___)
```


Табличку с данными иногда приходится сортировать!

Мы последовательно выполним два действия, сортировку и отбор самых верхних строк.

```{r}
diamonds6 <- arrange(diamonds, price) %>% head(3)
diamonds6
```

* Упражнение 6.

Отсортируйте бриллианты по массе и отберите самые нижние пять строк.

```{r}
# diamonds7 <- arrange(___, ___) %>% ___(5)
# diamonds7
```


# Россия - родина слонов!

С данными на русском языке иногда приходится повозиться:
пакет `rio` может не справляться с импортом русским букв.

Сейчас распространено две кодировки для русского текста: UTF-8 и CP1251.
Более современной является UTF-8 и сохранять свои файлы разумно именно в ней.
Однако приходится работать и с CP1251.

Перед нами два `csv` файла с русскими буквами `rus_utf8.csv` и `rus_cp1251.csv`.

* Упражнение 7.

Проверьте, читаются ли эти файлы командой `import()`
```{r}
# data_utf <- import("data/rus_utf8.csv")
# glimpse(___)
# data_cp <- import("data/rus_cp1251.csv")
# glimpse(___)
```
- В каком случае русские буквы читаются без кракозябр?

Здесь на помощь приходят другие пакеты, например, функция `read_csv` из пакета `readr`:
```{r}
# data_cp2 <- read_csv("data/rus_cp1251.csv", locale = locale(encoding = "CP1251"))
# glimpse(___)
# data_utf2 <- read_csv("data/rus_utf8.csv", locale = locale(encoding = "UTF8"))
# glimpse(___)
```


# Не пропадёт наш скорбный труд :)

Есть много форматов данных.
Самым простым и потому универсальным является формат `csv`,
comma separated values.
Этот формат понимают все программы, работающие с данными.

Экспортируем набор данных про бриллианты в `csv`:

```{r}
export(diamonds, "data/diamonds.csv")
```
Теперь эти данные можно прочитать в большинстве программ!
Ровно таким же образом можно экспортировать и в другие форматы:
  - `xlsx` для MS Excel
  - `dta` для stata
  - `sav` для spss

* Упражнение 8.

Экспортируйте набор данных `diamonds` в эксельчик.
```{r}
# export(___, ___)
```
Не забудьте, что имя файла должно быть в кавычках. Двойных или одинарных - не важно.


# Спасите-помогите

- Если хочется прочитать подробнее про конкретную функцию, например, про `filter`:
```{r, eval=FALSE}
?filter
```
- Если хочется посмотреть, какие функции живут в пакете, например, в `skimr`:
```{r, eval=FALSE}
help(package = "skimr")
```
- Иногда помимо занудного описания каждой функции пакет содержит "виньетки".
Виньетка - это пример использования пакета в бою.
Виньетка не обязана описывать каждую функцию пакета, зато может содержать гораздо больше пояснений.

Можно посмотреть, какие виньетки содержит пакет,
```{r, eval=FALSE}
vignette(package = "skimr")
```
А дальше, узнав название виньеток, прочитать любую из них, например,
```{r, eval=FALSE}
vignette("Using_skimr")
```

- Если хочется посмотреть, какие пакеты используют люди моей специальности, то можно зайти на [cran task view](https://cran.r-project.org/web/views/)

- Если хочется задать вопрос по статистике или поискать похожий, то поможет форум [stats.se](https://stats.stackexchange.com/)

- А здесь мы приготовили [подборку русскоязычных ресурсов по R](https://github.com/bdemeshev/r_links)


# Как обойтись без этого курса и платных программ? :)

Открытые и бесплатные программы для работы с данными, в которых можно кликать мышкой!

* [gretl](http://gretl.sourceforge.net/). Эконометрика. Достойный конкурент для stata и eviews.
* [jasp](https://jasp-stats.org/). Альтернатива spss. Байесовский подход сразу!
* [radiant](https://radiant-rstats.github.io/docs/). Довесок к R, позволяющий работать мышкой и превратить результат в набор команд R.
* [OpenRefine](http://openrefine.org/). Мощная чистка данных.

Ура :)
