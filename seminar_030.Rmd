---
title: 'Семинар 3. Метод главных компонент'
date: '24 сентября 2018'
output:
  html_document:
    keep_md: no
    number_sections: yes
    toc: yes
lang: ru-RU
editor_options:
  chunk_output_type: console
---


Мы поставим пакет `patchwork`, не выложенный на официальный репозиторий, от пользователя `thomasp85`. Томас придумал простой язык, чтобы рисовать несколько графиков рядом.

Ставим пакет Томаса:
```{r, eval=FALSE}
devtools::install_github("thomasp85/patchwork")
```


Шаманское заклинание для настройки глобальных опций отчёта:
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```


```{r}
library(tidyverse) # обработка данных, графики...
library(skimr)# описательные статистики
library(rio) # импорт фантастического количества форматов данных

library(cluster) # кластерный анализ
library(factoextra) # визуализации kmeans, pca,
library(dendextend) # визуализация дендрограмм

library(corrplot) # визуализация корреляций

library(broom) # метла превращает результаты оценивания моделей в таблички

library(naniar) # визуализация пропущенных значений
library(visdat) # визуализация пропущенных значений

library(patchwork) # удобное расположение графиков рядом
```



# Загружаем набор данных


Возьмём данные по потреблению белков (протеинов) в Европе из книги [Practial Machine Learning Cookbook](https://github.com/PacktPublishing/Practical-Machine-Learning-Cookbook/blob/master/Chapter%2003/Data/Europenaprotein.csv).
Загрузим их и посмотрим описательные статистики.
В наборе данных для каждой страны указано, сколько белка получает ежедневно житель из различных продуктов.

```{r}
protein <- import("data/Europenaprotein.csv")
skim(protein)
```

Отмасштабируем все числовые переменные с помощью функции `scale()`.
Затем спрячем текстовую переменную `Country` в названия строк:

```{r}
protein_no_country <- protein %>%
  mutate_if(is.numeric, ~ as.vector(scale(.))) %>%
  column_to_rownames(var = "Country")
```

Дополнение в виде функции `as.vector` нужно потому, что функция `scale` возвращает матрицу,
а каждый столбец должен быть вектором :)




# Метод главных компонент

Метод главных компонент: заменяем большое количество исходных переменных на меньшее количество
новых искусственных переменных, главных компонент.

Например, можно заменить 20 исходных переменных на две искусственные главные компоненты,
чтобы изобразить многомерный набор данных на двумерном графике.

Как переменные превращают в главные компоненты?

Для удобства представим, что у нас есть три исходные переменные, они центрированы и приведены к общему масштабу.

Подход А. Максимизация разброса.

В первую компоненту берём исходные три переменные с такими весами, чтобы:

- максимизировать разброс первой главной компоненты;
- сумма квадратов весов равнялась бы единице.

Формально:
\[
pc^{1}_i = \alpha_1 x_i + \alpha_2 y_i + \alpha_3 z_i
\]

МГК максимизирует $TSS(pc^1)=\sum (pc^1_i - 0)^2$ при ограничении $\alpha_1^2 + \alpha_2^2 + \alpha_3^2=1$.

Подход Б. Минимизация расстояний от точек до новой системы координат.

Мы хотим ввести новую прямую координат так,
чтобы прямая проходила на минимальном расстоянии от имеющихся точек.

\[
\sum (x_i - \hat x_i)^2 + \sum (y_i - \hat y_i)^2 + \sum (z_i - \hat z_i)^2 \to \min,
\]
при условии, что точки $\hat x_i$, $\hat y_i$, $\hat z_i$ лежат на одной прямой.

Эти подходы эквивалентны.

После применения метода главных компонент оказывается, что:

\[
TSS(pc^1) + TSS(pc^2) + TSS(pc^3) = TSS(x) + TSS(y) + TSS(z),
\]
где $TSS$ — сумма квадратов значений переменной. Напомним, что переменные у нас центрированы.


Реализуем метод главных компонент на данных о потреблении белка функцией `prcomp()`.
Передадим ей отмасштабированные данные `protein_no_country`, хотя так поступать и необязательно.
Другой путь — передать исходный набора данных и попросить функцию `procmp()` стандартизировать их
аргументом  `scale = TRUE`.

```{r}
protein_pca <- prcomp(protein_no_country)
protein_pca
```

Посмотрим, что лежит в этом списке!

```{r}
attributes(protein_pca)
```

Сами новые искусственные главные компоненты лежат в матрице `protein_pca$x`.
Например, первая главная компонента:
```{r}
protein_pca$x[, 1]
```

Выборочные стандартные отклонения компонент (корни из $\lambda_j$) лежат в векторе `protein_pca$sdev`:
```{r}
protein_pca$sdev
```

Матрица `protein_pca$rotation` содержит веса, с которыми исходные переменные входят в новые искуственные главные компоненты. Например, в первой главной компоненте лежат исходные переменные с весами:
```{r}
protein_pca$rotation[, 1]
```


Визуализируем данные в осях первых двух главных компонент.
Для этого воспользуемся функцией `fviz_pca_ind()` из пакета `factoextra`.
Рисовать будем `protein_pca`, а аргумент `repel = TRUE` укажем для того,
чтобы подписи на графике не перекрывали друг друга.

```{r}
fviz_pca_ind(protein_pca, repel = TRUE)
```

* Упражнение 5.

- Выделите главные компоненты на данных об арестах в Америке.
Будьте внимательны: эти данные мы не масштабировали!

- Визуализируйте данные в осях первых двух главных компонент.
Проследите, чтобы подписи точек на графике были аккуратными :)

```{r}
# usa_pca <- prcomp(___, scale. = ___)
# usa_pca
# fviz_pca_ind(___, repel = ___)
```

- Какой процент дисперсии объясняют в сумме первые две главные компоненты?
- Какой из штатов скорее можно назвать нетипичным, Калифорнию или Вирджинию?
- Какой из штатов наиболее похож на Техас?

Помимо самих данных, в осях главных компонент можно нарисовать проекции исходных переменных.
Сделаем это командой `fviz_pca_biplot()`.
Как и прежде, укажем, что мы хотим изобразить, и попросим сделать подписи аккуратными
аргументом `repel = TRUE`.

```{r}
fviz_pca_biplot(protein_pca, repel = TRUE)
```

- Какая исходная переменная входит в первую главную компоненту с большим положительным весом?
- Какая исходная переменная входит в первую главную компоненту с большим отрицательным весом?
- Как можно хотя бы примерно проинтепретировать первую главную компоненту?


* Упражнение 6.

Визуализируйте в осях первых двух главных компонент американские штаты и проекции
исходных переменных.

```{r}
# fviz_pca_biplot(___, ___ = TRUE)
```

- Какая исходная переменная входит в первую главную компоненту с большим отрицательным весом?
- Как можно хотя бы примерно проинтепретировать первую главную компоненту?
- Какие штаты можно считать самыми безопасными?


Теперь изобразим, какой процент разброса данных объясняет каждая главная компонента.
Будем использовать команду `fviz_eig()` из пакета `factoextra`.

```{r}
fviz_eig(protein_pca)
```

- Сколько нужно взять главных компонент, чтобы объяснить более 70% разброса исходных наблюдений?

* Упражнение 7.

Визиулизируйте процент разброса, который объясняет каждая главная компонента.
Обратите внимание, что у функции появился новый аргумент :)

```{r}
# fviz_eig(___, addlabels = TRUE)
```

- Какой процент разброса в данных объясняют в сумме третья и четвёртая глаыне компоненты?
- Что меняет аргумент `addlabels = TRUE`?


Выясним, какой влкад вносит каждая переменная в конкретную главную компоненту.
Для этого будем использовать команду `fviz_contrib()`.
Передадим ей объект `protein_pca` и в качестве аргументов укажем `choice = "var"`,
так как нам нужны именно переменные, а не наблюдения, и `axes = 1`,
чтобы посмотреть на первую главную компоненту.
Для визуализации вклада наблюдения значение аргумента `choice` поменяем на `ind`
и для разнообразия посмотрим на третью главную компоненту :)

```{r}
fviz_contrib(protein_pca, choice = "var", axes = 1)
fviz_contrib(protein_pca, choice = "ind", axes = 3)
```

- Какие переменные имеют наибольший вес в первой главной компоненте?
- Какая страна вносит наибольший вклад в сумму квадратов расстояний до центра для третьей главной компоненты?

* Упражнение 8.

Для данных по арестам визуализируйте вклад переменных во вторую главную компоненту
и вклад наблюдений в первую.

```{r}
# fviz_contrib(___, choice = "___", axes = ___)
# fviz_contrib(___, choice = ___, ___ = ___)
```


Ура! :)
